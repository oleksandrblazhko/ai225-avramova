## Основи програмного керування процесами в Unix-подібних ОС

### Перегляд інформації про процес

![зображення](https://user-images.githubusercontent.com/99131376/235862829-28662f44-32a6-4f0a-9762-4b5a8f50d0dd.png)

Рис. 1 – Фрагмент екрану з рішення завдання "2.1.1 Створити C-програму з назвою за шаблоном «ваше прізвище_process_info.c»,
наприклад, blazhko_process_info.c яка виводить на екран таку інформацію:
- ідентифікатор групи процесів, до якої належить процес;
- ідентифікатор процесу, що викликав цю функцію;
- ідентифікатор parent-процесу;
- ідентифікатор користувача процесу, який викликав цю функцію;
- ідентифікатор групи користувача процесу, який викликав цю функцію."

![зображення](https://user-images.githubusercontent.com/99131376/235862891-99142493-5aff-4294-b556-eacf710d7b42.png)

Рис. 2 – Фрагмент екрану з рішення завдання "2.1.2 Скомпілювати створену С-програму та запустити її дві копії у двох режимах за
прикладами з рисунку 4:
- паралельне виконання двох процесів;
- конвеєрне виконання двох процесів."

При паралельному виконанні двох процесів ID групи процесів, до якої належить процес відрізняється, в той час як при конвеєрному виконанні двох процесів ID групи процесів збігаються.

### Створення child-процесу
![зображення](https://user-images.githubusercontent.com/99131376/235898854-0b81158d-acfc-4965-8389-9cc818642d3e.png)

Рис. 3 – Фрагмент екрану з рішення завдання "2.2.1 Створити C-програму, яка породжує процес та замінює образ процесу на
команду у відповідності із варіантом з таблиці 3. Назва програми повинна співпадати з
назвою команди з таблиці 3, але з додатком у вигляді транслітерації вашого прізвища,
наприклад, touch_blazhko.c
Перед включенням відповідної команди з таблиці 3 до програмного коду перевірте
правильність її роботи зі звичайного командного рядку, щоб зрозуміти, що вона повинна
виводити на екран.
У програмі необхідно виконати наступне:
1) child-процес повинен вивести на екран повідомлення типу «the child of Students`
Surname executes: команда», наприклад, «the child of Blazhko executes: echo»;
2) заміна програмного образу child-процесу через функцію execv з урахуванням
аргументів команди, приклади яких наведено у стовпчику таблиці 3 (функція повинна
забезпечити виконання відповідної команди з урахуванням двох аргументів);
3) щоб повідомлення child-процесу не з’являлося пізніше виконання функції execv
через окремі затримки у процесах рекомендується перед функцією execv додати функцію
затримки, наприклад, sleep(1)."

![зображення](https://user-images.githubusercontent.com/99131376/235899100-31ccb8a6-8842-4ffa-ac11-9a3b1bbc0048.png)

Рис. 3 – Фрагмент екрану з рішення завдання "2.2.2 Скомпілювати програму та перевірити її роботу."

### Обмін сигналами між процесами
![зображення](https://user-images.githubusercontent.com/99131376/235927819-880f3b4e-5766-4243-8ae8-33fcb3bf99f0.png)

Рис. 4 – Фрагмент екрану з рішення завдання "2.3.1 Створити C-програму з назвою «ваше прізвище_get_signal», в якій процес
очікує отримання сигналу SIGUSR2 та виводить повідомлення типу «Process of Students`
Surname got signal» після отримання сигналу, де замість слова Students` Surname в
повідомленні повинно бути ваше прізвище в транслітерації."

![зображення](https://user-images.githubusercontent.com/99131376/235928466-b5f94f2a-d3d5-47a0-85b4-103b578c1f7d.png)

Рис. 5 – Фрагмент екрану з рішення завдання "2.3.2 Скомпілювати програму та запустити її."

![зображення](https://user-images.githubusercontent.com/99131376/235928684-aea45244-4158-4e31-aee5-750ebb9fbd30.png)

Рис. 6 – Фрагмент екрану з рішення завдання "2.3.3 Використовуючи інший псевдотермінал, створити C-програму з назвою «ваше прізвище_set_signal», яка надсилає сигнал SIGUSR2 процесу, запущеному в попередньому пункті завдання."

![зображення](https://user-images.githubusercontent.com/99131376/235929214-1d0bf087-87fb-4069-9388-a3665336e2ff.png)

Рис. 7 – Фрагмент екрану з рішення завдання "2.3.4 Скомпілювати другу створену С-програму та запустити її в іншому
псевдотерміналі, проаналізувавши повідомлення, які в першому псевдотерміналі виводить перша програма. Завершити процес, запущений в попередньому пункті завдання."

### Створення процесу-сироти
![зображення](https://user-images.githubusercontent.com/99131376/235933194-da4bcb35-b0a4-4f1d-80b7-954fc506024c.png)
Рис. 8 – Фрагмент екрану з рішення завдання "2.4.1 Створити C-програму з назвою «ваше прізвище_orphan», в якій parent-процес несподівано завершується раніше child-процесу. Parent-процес повинен очікувати завершення n+1 секунд. Child-процес повинен в циклі (2*n+1) разів із затримкою в 1 секунду виводити повідомлення, наприклад, «Parent of Students` Surname», за шаблоном як в попередньому завданні, і додатково виводити PPID parent-процесу. Значення n – номер вашого варіанту."

![зображення](https://user-images.githubusercontent.com/99131376/235933055-9398185b-84bc-40e0-9d17-48bf247818c9.png)

Рис. 9 – Фрагмент екрану з рішення завдання "2.4.2 Скомпілювати програму та перевірити її роботу."

Після виконання завдання можна зробити такий висновок - батьківський процес очікує завершення дочірнього процесу, а дочірній процес виконується протягом певного часу, виводячи на екран повідомлення про батьківський процес та його PID. При несподіваному завершенні батьківського процесу дочірній процес стає "сиротою".

### Створення zombie-процесу
![зображення](https://user-images.githubusercontent.com/99131376/235978382-40b75c32-a03e-49f9-a1fe-e698492f966e.png)

Рис. 10 – Фрагмент екрану з рішення завдання "2.5.1 Створити C-програму з назвою «ваше прізвище_zombie», в якій child-процес
несподівано завершується раніше parent-процесу, перетворюється на zombie-процес, виводячи в результаті повідомлення, наприклад, «I am Zombie-process of Students` Surname», за шаблоном як в попередньому завданні."

![зображення](https://user-images.githubusercontent.com/99131376/235978280-bcb0c873-b7db-4c43-9e66-8d9416428c7c.png)

Рис. 11 – Фрагмент екрану з рішення завдання "2.5.2 Скомпілювати програму та запустити її у фоновому режимі."
В таблиці процесів ми бачимо, що процес став zombie-процесом, проте дуже швидко, коли parent-процес завершиться, буде очищена таблиця процесів
від цього child-процесу.

### 
![зображення](https://user-images.githubusercontent.com/99131376/235981214-e49e229f-fbbb-4448-b7d7-40374ce05280.png)

Рис. 12 – Фрагмент екрану з рішення завдання "2.6.1 Створити C-програму з назвою «ваше прізвище_zombie_stop», в якій child-
процес також як в попередньому завданні може перетворитися на zombie-процес, але ця подія вже повинна контролюватися parent-процесом.
Child-процес повинен виводити повідомлення, наприклад, «Child of Students` Surname is finished», за шаблоном як в попередньому завданні. Parent-процес повинен очікувати (3*n) секунд. Значення n – номер вашого варіанту."

![зображення](https://user-images.githubusercontent.com/99131376/235980950-14d738f8-75db-4b2d-a61e-2603b231aa8e.png)

Рис. 13 – Фрагмент екрану з рішення завдання "2.6.2 Скомпілювати програму та запустити її у фоновому режимі. Переглянути вміст таблиці процесів зі станами процесів та зробити відповідні висновки."

Процес тепер має статус Z (зомбі), а ім’я взято в квадратні дужки зі словом «неіснуючий» поруч. Це означає, що процес завершив виконання, але ще не був очищений батьківським процесом. Однак у цьому випадку батьківський процес уже викликав wait(), щоб очистити дочірній процес, тому процес-зомбі незабаром зникне з таблиці процесів.














