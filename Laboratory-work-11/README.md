## Етапи компіляції С-програм та автоматизація побудови С-програм

### 1 Побудова програми з’єднання з СКБД PostgreSQL на основі монолітної С-програми

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/8772c341-b2ff-43f3-aec5-aaf3ba1f4488)

Рис. 1 Фрагмент рішення екрану "2.1.1 Створити C-програму з назвою «db_connect.c», яка:
- встановлює з'єднання із СКБД PostgreSQL;
- під час з’єднання використовує назву БД та користувача з попередньої лабораторної роботи, які вбудовані в програмний код;
- обробляє результат з’єднання (успішно та помилкове), виводячі на екран відповідні повідомлення, які враховують назву БД;
- увесь програмний код розміщується лише у функції main."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/555e524b-cab1-452d-82b1-09a184454789)

Рис. 2 Фрагмент рішення екрану "2.1.2 Скомпілювати С-програму, враховуючи каталоги з header-файлами та бібліотеками СКБД PostgreSQL. Перевірити роботу executable-файла."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/1a097e1b-50e6-45bf-aa52-8bf2b91553d3)

Рис. 3 Фрагмент рішення екрану "2.1.3 Створити C-програму з назвою «db_connect_param.c», яка повторює всі дії C-програми з назвою «db_connect.c», але назву бази даних та ім’я користувача програма повинна брати як параметри командного рядку."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/d01ed901-f171-43d8-8738-0145324e8cdc)

Рис. 4 Фрагмент рішення екрану "2.1.4 Скомпілювати С-програму, враховуючи каталоги з header-файлами та бібліотеками СКБД PostgreSQL. Перевірити роботу executable-файла за двома варіантами назви БД: правильна назва та будь-яка неправильна БД."

### 2 Побудова програми з’єднання з СКБД PostgreSQL за модульним принципом програмування

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/ad1be58e-26e4-40c9-9b01-ac88bab16ea3)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/c00337e5-0ecc-495d-8450-6984034a8c64)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/bec76ba4-df3d-471a-bc4c-0f46a2f969d1)

Рис. 5 Фрагмент рішення екрану "2.2.1 Змінити код С-програми, враховуючи модульний принцип програмування:
- оформити програмний код з’єднання із СКБД PostgreSQL у вигляді функції з назвою «connect_назва таблиці», де «назва таблиці» - назва реляційної таблиці з попередньої лабораторної работи;
- розмістити функцію у С-файлі із такою ж назвою, як назва функції;
- створити header-файл за шаблоном «назва таблиці.h» та додати до файлу декларацію створеної функції;
- виконати виклик функції із main-функції файлу з назвою «назва таблиці.c»"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/20613526-fdbe-41b2-b775-ee9ce519efb5)

Рис. 6 Фрагмент рішення екрану "2.2.2 Скомпілювати С-програму, враховуючи каталоги з header файлами, бібліотеками СКБД PostgreSQL та модульність програми. Перевірити роботу executable-файла."

### 3 Побудова програми з’єднання з СКБД PostgreSQL через команду make

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/c7a03c06-b96a-4781-a577-9c6d6cdb10de)

Рис. 7 Фрагмент рішення екрану "2.3.1 Створити Makefile, який містить наступний опис мети:
- мета компіляції програми з назвою «назва таблиці.c»
- мета компіляції файлу з функцією."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/4c38102c-da37-4593-9956-cf7031b0e1af)

Рис. 8 Фрагмент рішення екрану "2.1.2 Скомпілювати С-файли програмних модулів командою make."

### 4 Побудова програми видалення рядку реляційної таблиці

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/fd27ba53-d345-4037-8f0a-4bdb4735fb52)

Рис. 9 Фрагмент рішення екрану "2.4.1 Створити файл як програмний модуль з назвою «remove_назва таблиці.с» із описом функції видалення рядку реляційної таблиці, яка повинна містити:
- команди транзакції (START TRANSACTION, LOCK TABLE назва таблиці ..., DELETE FROM назва таблиці ..., COMMIT);
- повідомлення про результат виконання кожної команди.
Команду DELETE FROM створити за прикладом з попередньої лабораторної роботи."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/f75c841e-0d43-476b-9724-6f7d0a6c393a)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/20f9d4a6-ddbd-4723-85bd-e660e0006c70)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/cdf8d127-1038-42d2-87fd-0278e4ece76a)

Рис. 10 Фрагмент рішення екрану "2.4.2 Оновити раніше створені файли:
- додати до файлу «назва таблиці».h декларацію нової функції;
- виконати виклик нової функції із main-фукції файлу «назва таблиці».c
- додати опис нової мети у файл Makefile"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/4d2e3727-2eb6-44df-9667-d20cc0528035)

Рис. 11 Фрагмент рішення екрану "2.4.3 Скомпілювати С-файли програмних модулів командою make. Перевірити роботу executable-файла."

### 5 Побудова програми додавання рядку реляційної таблиці

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/75fc7e5d-adea-4789-9e0a-115c7622dc00)

Рис. 12 Фрагмент рішення екрану "2.5.1 Створити файл як програмний модуль з назвою «add_назва таблиці.с» із описом функції додавання рядку реляційної таблиці, яка повинна містити:
- команди транзакції (START TRANSACTION, LOCK TABLE назва таблиці ..., INSERT INTO назва таблиці ..., COMMIT);
- повідомлення про результат виконання кожної команди.
Команду INSERT INTO створити за прикладом з попередньої лабораторної роботи."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/33792fc8-e3a4-49a3-8542-f3bdaf84f9ee)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/816c4fc2-b001-4d04-97c0-77cff9311568)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/b2d31342-8b70-4c21-b412-5c4875c7f9cf)

Рис. 13 Фрагмент рішення екрану "2.5.2 Оновити раніше створені файли:
- додати до файлу «назва таблиці.h» декларацію нової функції;
- виконати виклик нової функції із main-фукції файлу «назва таблиці.c»
- додати опис нової мети у файл Makefile"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/ec2974fe-00ec-4a60-a67d-fbabdc61b33f)

Рис. 14 Фрагмент рішення екрану "2.5.3 Скомпілювати С-файли програмних модулів командою make."

### 6 Побудова програми перегляду рядків реляційної таблиці

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/843cd34c-fec3-441e-a78d-c2a8bb91e862)

Рис. 15 Фрагмент рішення екрану "2.6.1 Створити файл як програмний модуль з назвою «get_назва таблиці».с із описом функції перегляду рядків реляційної таблиці, яка повинна містити:
- команди транзакції (START TRANSACTION, LOCK TABLE назва таблиці ..., SELECT ... FROM назва таблиці ..., COMMIT);
- повідомлення про результат виконання кожної команди.
Команду SELECT ... FROM створити за прикладом з попередньої лабораторної роботи."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/c021577e-f2d0-464c-9ac7-6dd950472942)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/f5353dd5-b4a7-455e-9131-258f7175252d)
![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/25aa9737-517c-4cf1-afbb-a12c7c32cd0c)

Рис. 16 Фрагмент рішення екрану "2.6.2 Оновити раніше створені файли:
- додати до файлу «назва таблиці».h декларацію нової функції;
- виконати виклик нової функції із main-фукції файлу «назва таблиці».c
- додати опис нової мети у файл Makefile"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/ca78d9cd-dff4-468b-a790-6511c38e645c)

Рис. 17 Фрагмент рішення екрану "2.6.3 Скомпілювати С-файли програмних модулів командою make. Перевірити роботу executable-файла."

### 7 Додаткове налаштування процесу керування файлами через команду make

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/1bff7289-34f9-478c-a249-842b1235d79d)

Рис. 18 Фрагмент рішення екрану "2.7.1 Додати до файлу Makefile наступні описи мети: 
install – копіювання executable-файлу до каталогу /home/ваш_користувач/bin (попередньо створити такий каталог);
clean – очистка всіх object-файлів та executable-файлу."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/fc65c77d-6644-4ba6-ae39-caf885fcce1d)

Рис. 19 Фрагмент рішення екрану "2.7.2 Виконати команду make з метою clean. Перевірити відсутність всіх object-файлів та executable-файлу."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/853c32f2-dee2-4db2-b808-3477ce575894)

Рис. 20 Фрагмент рішення екрану "2.7.3 Скомпілювати С-файли програмних модулів командою make."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/3313169c-c2e6-4eef-b71a-8ebf9778a603)

Рис. 21 Фрагмент рішення екрану "2.7.4 Виконати команду make з метою install. Перевірити роботу executable-файла без необхідності вказувати до нього шлях доступу."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/2fd97c3a-ae19-4a7d-bab0-89d7a670d182)

Рис. 22 Фрагмент рішення екрану "2.7.5 Повторно скомпілювати С-файли програмних модулів командою make. Надати висновки щодо повідомлення команди."

Повідомлення "make: 'calculator' is up to date" означає, що файл виконуваної програми з назвою "calculator" уже є актуальним і не потребує повторної компіляції. Це означає, що жоден з вихідних файлів програмних модулів або залежностей не зазнав змін після останньої компіляції.

### 8 Огляд етапів побудови С-програми GNU-компілятором GCC

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/7aa858b1-7531-4dbc-b39b-624efb0e6ede)

Рис. 23 Фрагмент рішення екрану "2.8.1 Виконати prepocessing-етап для вказаного файлу, зберігши результат у файлі «назва таблиці.i»"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/4cd3659d-35d0-4fb3-a6f1-a61db919600a)

Рис. 24 Фрагмент рішення екрану "2.8.2 Виконати compilation-етап для файлу «назва таблиці.i», зберігши результат у файлі «назва таблиці.s»"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/dfc21ade-b66b-4349-8fc3-d284f2073687)

Рис. 25 Фрагмент рішення екрану "2.8.3 Повторити compilation-етап для файлу «назва таблиці.i» з оптимізацію програмного коду, зберігши результат у файлі «назва таблиці_opt.s», та визначити відсоток зменшення кількості рядків після оптимізації."

Кількість рядків у файлі "person.s" становить 44 рядків, а кількість рядків у файлі "person_opt.s" становить 40 рядки. Після оптимізації кількість рядків зменшилась на близько 10%.

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/6e750b35-abc7-466f-b76f-131040d2a1ec)

Рис. 26 Фрагмент рішення екрану "2.8.4 Виконати assembly-етап для файлу «назва таблиці.i», зберігши результат у файлі «назва таблиці.o»"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/3626bcf1-b08b-4d84-94a9-9867c428da6c)

Рис. 27 Фрагмент рішення екрану "2.8.5 Визначити командний рядок виконання linking-етапу для файлу «назва таблиці.o» та зберегти результат у файл-скрипті ld.sh"

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/a9627104-8846-4c3b-b60b-cdfc6b38953b)

Рис. 28 Фрагмент рішення екрану "2.8.6 Виконати linking-етап через виконання створеного раніше файл-скрипту ld.sh."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/320e16e8-9565-4f4a-9370-36fc925a356e)

Рис. 29 Фрагмент рішення екрану "2.8.7 Переглянути список файлів динамічних бібліотек, пов’язаних зі створеним executable-файлом."
