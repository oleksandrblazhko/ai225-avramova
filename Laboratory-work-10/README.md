## Керування процесами-транзакціями в базах даних

### 2.1.1 Створити історію квазіпаралельного успішного виконання транзакцій для протоколу 1-го ступеня блокування.
Описати таблицю блокування транзакцій до моменту першої фіксації змін однієї з
транзакцій у вигляді масиву на мові програмування С.

T1= R[A] R[B] W[A] C1
T2= W[D] R[B] W[B] C2
T3= R[D] W[D] C3

H1(T1,T2,T3) = R[A] X1[D] W[D] R[D] R[B] R[B] X2[D]-Wait W[D] X3[A]-Wait W[A] X4[B]-Wait W[B] X2[D] W[D] X3[A]-Wait W[A] X4[B]-Wait W[B] C3 U3 X3[A] W[A] X4[B]-Wait W[B] C1 U1 X4[B] W[B] C2 U2

char* lock_table[][3] = { { "A", " ", "X3"}, 
                          { "D", "X1", "X2"}, 
                          { "B", " ", "X4"} }; 

### 2.1.2 Для створеної історії з попереднього завдання визначити наявність Deadlock-стану транзакції, створивши граф очікування транзакцій, та зробити відповідник висновок.
Представити граф у вигляді масиву на мові програмування С.

int wait [][6]= { {2,1}, {3,2}, {4,3}, {3,2}, {4,3}, {4,3}};

Цикл відсутній, тому deadlock-стан відсутній.

### 2.1.3 Створити історію квазіпаралельного успішного виконання транзакцій для протоколу 2-го ступеня блокування.
Описати таблицю блокування транзакцій до моменту першої фіксації змін однієї з
транзакцій у вигляді масиву на мові програмування С.

H2(T1,T2,T3) = S1[A] R[A] X1[D]-Wait S2[D] R[D] S3[B] R[B] S3[B] R[B] X2[D]-Wait X3[A]-Wait X4[B]-Wait

char* lock_table[][3] = { { "A", "S1", "X3"}, 
                          { "D", "S2", "X1, X2"}, 
                          { "B", "S3", "X4"} }; 
                          
### 2.1.4 Для створеної історії з попереднього завдання визначити наявність Deadlock-стану транзакції, створивши граф очікування транзакцій, та зробити відповідник висновок.
Представити граф у вигляді масиву на мові програмування С.

int wait [][4]= { {1,2}, {2,3}, {3,4}, {4,1} };

Цикл присутній, тому deadlock-стан присутній.

### 2 Налаштування бази даних

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/99147d2a-d731-48b4-8ec6-f5c826dd75de)

Рис. 1 Фрагмент рішення екрану "2.2.1 Встановити з’єднання з БД, назва якої співпадає з іменем вашого користувача в ОС Linux, використовуючи користувача СКБД за таким же іменем."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/122f3923-7391-46e1-873f-cc6f57ac7f0b)

Рис. 2 Фрагмент рішення екрану "2.2.2 Виконати команди отримання імені поточного користувача СКБД та назви БД."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/d9ada62d-c184-4322-85d2-6e7a91c0908a)

Рис. 3 Фрагмент рішення екрану "2.2.3 У відповідності із варіантом з таблиці 16 створити реляційну таблицю."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/c2623c98-94ba-4b20-82a3-190c4a964cb8)

Рис. 4 Фрагмент рішення екрану "2.2.4 У відповідності із варіантом з таблиці 16 додати рядок в реляційну таблицю."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/6856c987-f159-4fd3-b1b7-dc153c4cfbb5)

Рис. 5 Фрагмент рішення екрану "2.2.5 Створити ще одну операцію внесення рядка в таблицю, який буде відрізнятися значеннями всіх змінних (стовпчиків) від прикладу з варіанту, а одна із змінних повинна враховувати значення із транслітерацією вашого прізвища."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/d04a8b52-d06c-4bb3-80b7-6164453a0208)

Рис. 6 Фрагмент рішення екрану "2.2.6 Переглянути зміст таблиці, враховуючи всі стовпчики всіх рядків таблиці."

### 3 Керування квазіпаралельним виконанням транзакцій з використанням команд блокування

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/8e9165bb-1b1e-4fd0-b079-edf3beff5482)

Рис. 7 Фрагмент рішення екрану "2.3.1 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_1.sql», наприклад, blazhko_transaction_lock_1.sql, та додати до нього операції двох транзакцій, кожна з яких повинна включати наступні операції:
- операція блокування для протоколу 1-го ступеня блокування;
- операція читання всіх стовпчиків першого рядку таблиці;
- операція зміни значення другого стовпчика таблиці у першому рядку;
- повторна операція читання всіх стовпчиків першого рядку таблиці;
- операція фіксації всіх виконаних операцій."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/b1bb14ed-abd8-4d3e-911d-87260ba812f7)
Перший псевдотермінал:


![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/36f73e7f-727a-4e6d-abc5-9a5f68cf1bd2)
Другий псевдотермінал:

Рис. 8 Фрагмент рішення екрану "2.3.2 У двох псевдотерміналах виконати операції транзакцій при їх квазіпаралельному режимі роботи за умови, що одна з транзакція стартує першою."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/56a5e343-d10a-45dc-ae8a-d56254ec10e7)
Перший псевдотермінал:


![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/3fe70ecb-3574-40d1-b20b-445d0a67edde)
Другий псевдотермінал:

Рис. 9 Фрагмент рішення екрану "2.3.3 Повторити роботу транзакцій, але у першій транзакції замість операції фіксації виконати операцію відміни всіх операцій транзакції."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/f6f74f54-bf00-4e09-b99a-9603676e02d1)

Рис. 10 Фрагмент рішення екрану "2.3.4 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_2.sql», наприклад, blazhko_transaction_lock_2.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже враховуючи протокол 2-го ступеня блокування."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/c70c5403-2402-4c60-8910-d0a7c568445f)
Перший псевдотермінал:


![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/5d1dfdd2-742a-4b89-9cc9-ab1735b0af44)
Другий псевдотермінал:

Рис. 11 Фрагмент рішення екрану "2.3.5 Повторити роботу транзакцій з використанням протоколу 2-го ступеня блокування, але з додатковим параметром NOWAIT."

### 4 Керування квазіпаралельним виконанням транзакцій при наявності Deadlock-станів

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/417b8bf4-20e8-4f1e-93a4-c79ee2ed769f)

Рис. 12 Фрагмент рішення екрану "2.4.1 Створити файл з назвою за шаблоном «ваше прізвище_deadlock.sql», наприклад, blazhko_deadlock.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже модифікованого так, щоб транзакції призводили до Deadlock-стану."

![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/f127ac5e-937d-4dec-9f1c-f91601c9d39c)
Перший псевдотермінал:


![зображення](https://github.com/oleksandrblazhko/ai225-avramova/assets/99131376/906c33b3-0a81-4d7e-93af-0c399a7b4872)
Другий псевдотермінал:

Рис. 13 Фрагмент рішення екрану "2.4.2 Виконати модифіковані транзакції. Проаналізувати реакцію СКБД на операцію зміни значення стовпчика для транзакції, яка виконувалася пізніше (призвела до Deadlock-стану), та надати висновки за результатами аналізу з урахуванням ідентифікаторів процесів та номерів транзакцій."

З ідентифікатора процесу та номера транзакції можна визначити, що процес з ідентифікатором 645841 (термінал 2) очікує на транзакцію 1787 ShareLock; процес з ідентифікатором 645836 (термінал 1) очікує на транзакцію 1788 ShareLock. Таким чином, обидва процеси блокують один одного і утримують необхідні блокування для продовження виконання. Deadlock-стан виникає, коли два або більше процесів блокують необхідні ресурси один одного, і жоден з них не може продовжувати роботу, оскільки чекає на ресурси, які утримуються іншим процесом.
